@startuml

actor User as U
participant Wallet as W
box Issuer
participant "Issuer Site" as IS
participant "Server Metadata" as metadata
participant "Nonce Endpoint" as init
participant "Pushed Authorization Endpoint" as PAR
participant "Authorization Endpoint" as AS
participant "Token Endpoint" as T
participant "Credential Endpoint" as P
participant "Deferred Credential" as I
participant "Issuer Backend" as B
end box
autoactivate on
hide footbox

IS -> W: Initiate Issuance (issuer, op_state, ..., I want to push later)

U -> W: interact
note over W: Wallet discovers input material\nrequired to request issuance\nof a certain credential (Optional)

W -> metadata: (OPTIONAL) get credential manifests
return credential manifests

W -> init: (OPTIONAL) get_presentation_nonce
return p_nonce

W -> W: (OPTIONAL) prepare presentations (bound to presentation_nonce)
deactivate W

W -> PAR: (OPTIONAL) authorize (claims [determines credential types], (opt) vp_token, ...)

return request_uri

note over W: Wallet will seek authorization to receive multiple credentials as they become available a the issuer
W -> AS: authorize (claims [determines credential types], (opt) vp_token, ... OR request_uri, **callback_url**)
note over AS: Issuer will authenticate user or utilize credentials or assertions to identify user. \noptions: local login, callback to wallet (OIDC4VPs), federated login (via OpenID or SAML), ...

return code

W -> T: token (code, ...)
return access_token, id_token(, c_nonce)

...

B -> W: ping (credential_type, tx_id?)

note over W: access token or user pin used for API authorization (allows headless issuance)
W->P: credentials (access_token, user_pin, type, did, proof)
note over W: better called issuance endpoint?

return credential or acceptance_token(, c_nonce)

note over W: better called credential collection endpoint?
W->I: deferred credential request (acceptance_token)
return credential

@enduml